# Итоги тестирования pynput для подавления клавиш

## Цель
Реализовать приложение на pynput, которое:
1. Перехватывает RCtrl+Backspace
2. Показывает уведомление
3. **НЕ отдаёт** эту комбинацию в другие приложения
4. Продолжает работать (не завершается)
5. Пропускает все остальные клавиши в систему

## Протестированные подходы

### Подход 1: `suppress=True` + эмуляция через `Controller`
**Код:** `suppress=True`, все события блокируются, эмулируем нужные обратно через `controller.press/release`

**Результат:**
- ✅ RCtrl+Backspace можно перехватить
- ✅ Можно показать уведомление
- ❌ **События перестают доходить в другие приложения** (после обработки комбинации)
- ❌ **Проблема с `injected` событиями**: эмулированные события возвращаются в listener, создавая циклы

**Причина проблемы:** 
- `suppress=True` блокирует ВСЕ события
- Controller генерирует события как `injected=True`
- Нужно правильно игнорировать `injected` события, иначе рекурсия
- Сложность в том, что нужно вручную эмулировать ВСЕ события обратно

### Подход 2: `suppress=False` + `return False`
**Код:** `suppress=False`, используем `return False` для конкретной комбинации

**Результат:**
- ✅ Можно перехватить событие
- ❌ **`return False` не подавляет событие**, оно всё равно доходит до других приложений
- ❌ **`return False` останавливает listener** (программа завершается)

**Причина проблемы:**
- `return False` в callback НЕ означает "подавить это событие"
- `return False` означает "остановить listener"
- `suppress=False` не даёт нам контроля над подавлением конкретных событий

## Выводы

### Почему pynput не подходит для точечного подавления:

1. **Нет механизма выборочного подавления**:
   - `suppress=True` - подавляет ВСЁ, требует эмуляции всего обратно
   - `return False` - останавливает listener, не подавляет событие
   - Нет способа сказать "подавить только это событие, остальные пропустить"

2. **Проблема с эмуляцией**:
   - Эмулированные события с `injected=True` возвращаются в listener
   - Нужна сложная логика с флагами/counters для различения своих и чужих событий
   - Риск бесконечных циклов и зависаний

3. **Архитектурное ограничение pynput**:
   - pynput designed для мониторинга, НЕ для перехвата и модификации событий
   - Семантика callback'ов: `return False` = стоп listener, а не "подавить событие"
   - Нет способа "пропустить событие мимо ОС" в контексте одного события

### Что нужно для решения:

**ЭВДЕВ + uinput**:
1. `device.grab()` - эксклюзивный доступ к клавиатуре (НЕ блокирует, но получает все события первым)
2. Читаем события через `device.read_loop()`
3. Для подавленных комбинаций - просто не эмулируем
4. Для остальных - эмулируем через отдельное uinput устройство
5. Эмулированные события имеют другой source, их можно различить

**Почему это работает:**
- evdev работает на уровне /dev/input/
- Можем контролировать какие события "пускаем дальше" (эмулируем в другое устройство)
- Нет проблемы с injected событиями - они приходят от другого устройства
- Более низкий уровень = больший контроль

## План дальнейших действий:

1. Создать POC на evdev + uinput
2. Проверить, что точечное подавление работает корректно
3. Интегрировать этот подход в tap_launcher

