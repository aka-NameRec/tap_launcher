# Очистка виртуальных uinput устройств

## Проблема

Виртуальные uinput устройства (`py-evdev-uinput`) остаются в системе после завершения программ `tap-launcher` или `tap-detector`.

## Причины

1. **Программы были прерваны до вызова cleanup**:
   - Kill сигнал (SIGKILL) не позволяет выполнить cleanup
   - Необработанные исключения могут прервать выполнение до finally блока
   - Ctrl+C может не вызвать корректный shutdown

2. **Механизм работы uinput в Linux**:
   - Виртуальное устройство создаётся в `/dev/input/event*` при создании UInput объекта
   - Устройство автоматически удаляется ядром **только** при закрытии файлового дескриптора
   - Если процесс упал или файловый дескриптор утерян, устройство остаётся

3. **Зависшие процессы**:
   - Иногда процессы могут зависнуть в ожидании событий и не завершиться корректно

## Решение

Добавлены механизмы надёжного cleanup:

1. **atexit handlers** - закрытие устройств при нормальном завершении программы
2. **Signal handlers** (SIGTERM, SIGINT) - закрытие при получении сигналов
3. **Глобальный cleanup** - отслеживание всех экземпляров EvdevBackend и их очистка
4. **Улучшённый finally блок** - гарантированная очистка в любом случае

## Проверка зависших процессов

```bash
# Показать процессы, использующие uinput устройства
fuser /dev/input/event* 2>/dev/null

# Показать все Python процессы, связанные с tap-launcher/detector
ps aux | grep -E "tap-launcher|tap-detector|python.*tap" | grep -v grep

# Принудительно завершить зависшие процессы
kill -9 <PID>
```

## Очистка устройств вручную

Если устройства остались после завершения всех процессов:

1. **Перезагрузка системы** - самый надёжный способ (ядро очистит все uinput устройства)

2. **Поиск зависших процессов**:
   ```bash
   # Найти процессы, держащие устройства
   lsof /dev/input/event* | grep -v COMMAND
   
   # Убить процесс
   kill -9 <PID>
   ```

3. **Проверка, что устройства действительно не используются**:
   ```bash
   # Попробовать открыть устройство (должно быть ошибка "No such device" если оно исчезло)
   cat /dev/input/event19
   ```

## Предотвращение проблемы

1. **Всегда использовать корректное завершение**:
   - `tap-launcher stop` вместо `kill`
   - Ctrl+C в foreground режиме
   - SIGTERM вместо SIGKILL

2. **Мониторинг процессов**:
   ```bash
   # Проверить статус tap-launcher
   uv run tap-launcher status
   
   # Просмотр логов на предмет ошибок
   tail -f ~/.local/share/tap-launcher/tap-launcher.log
   ```

3. **Использование новой версии с улучшенным cleanup**:
   - В новой версии добавлены atexit и signal handlers
   - Устройства должны закрываться даже при аварийном завершении

## Технические детали

### Как работает cleanup в новой версии

```python
# При создании EvdevBackend:
- Регистрируется в глобальном set _instances
- Регистрируется atexit handler для всех экземпляров
- Устанавливаются signal handlers для SIGTERM и SIGINT

# При завершении:
- atexit handler вызывает _global_cleanup()
- signal handler также вызывает cleanup перед exit
- finally блок в start() гарантирует закрытие устройств
- stop() метод удаляет экземпляр из _instances
```

### Почему устройства могут остаться

1. **SIGKILL (-9)** - необрабатываемый сигнал, cleanup не выполняется
2. **Краш Python интерпретатора** - не выполняется atexit
3. **Зависший процесс** - не доходит до cleanup кода
4. **Конкуренция при создании** - несколько процессов создают устройства

## Рекомендации

1. Если видите много виртуальных устройств - проверьте зависшие процессы
2. Используйте `device-list` для мониторинга количества устройств
3. При необходимости перезагрузите систему для полной очистки
4. При разработке/тестировании - всегда корректно завершайте процессы

